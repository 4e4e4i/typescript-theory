# typescript-theory

## Введение в TypeScript

### Что такое TypeScript

TypeScript представляет язык программирования на основе JavaScript.

Следует отметить, что TypeScript - это строго типизированный и компилируемый язык. Хотя на выходе компилятор создает все
тот же JavaScript, который затем исполняется браузером. Однако строгая типизация уменьшает количество потенциальных
ошибок, которые могли бы возникнуть при разработке на JavaScript.

Так же TypeScript реализует многие концепции, которые свойственны объектно-ориентированным языкам, как, например, наследование,
полиморфизм, инкапсуляция и модификаторы доступа и так далее.

Потенциал TypeScripta позволяет быстрее и проще писать большие и сложные комплексные программы, соответственно их легче
поддерживать, развивать, масштабировать и тестировать, чем на стандартном JavaScript.

TypeScript является надмножеством JavaScript, а это значит, что любая прогррама на JS является программой на TypeScript.
В TS можно использовать все те конструкции, которые применяются в JS - те же операторы, условные, циклические конструкции.
Более того код на TS компилируется в JS. В конечно счете, TS - это всего лишь инструмент, который призван облегчить
разработку приложений.


## Основы TypeScript

### Переменные и константы

Для хранения данных в программе в TypeScript, как и во многих языках программирования использются переменные.

Для определения переменных, как в JS, можно использовать ключевое слово var:

```typescript
var z; // переменная z
```

Другой способ определения переменной применяет ключевое слово let, которое было добавлено в JS в стандарте ES 2015:

```typescript
let z;
``` 

Применение let является более предпочтительным, поскольку позволяет избежать ряд проблем, связанных с объявлением переменных.
В частности, с помощью var мы можем определить два и более раз переменную с одним и тем же именем:

```typescript
var x = 'Hello';
console.log(x);
var x = 'work';
console.log(x);
```

Если программа большая, то мы можем не уследить за тем, что такая переменная уже объявлена, что является источником потенциальных
ошибок. Подобную проблему позвляет решить let:

```typescript
let x = "Hello";
console.log(x);
let x = "work"; // здесь будет ошибка, так как переменная x уже объявлена
console.log(x);
``` 

Хотя var по прежнему можно использовать.

Определив переменную, мы можем установить ее значение и в процессе работы программы поменять его на другое:

```typescript
let z = 6;
z = 8;
```

Кроме переменных в TS имеются константы - для них можно установить значение только один раз. И даллее в процессе работы
программы мы уже не сможем изменить это значение. Для определение констант используется ключевое слово const:

```typescript
const z = 6;
z = 8; // Здесь ошибка - нельзя изменить значение константы z
```

<table>
    <thead>
          <tr>
              <td>var</td>
              <td>let/const</td>
          </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <p>
                    Доступна в любой части функции, в которой она определена
                </p>
                <pre>
function print(){
    if(1) {
        var x = 94;
    }
    console.log(x); // норм
}
                </pre>
            </td>
            <td>
                <p>
                    Доступна в рамках блока, в котором она определена
                </p>
                <pre>
function print(){
 if(1) {
     let x = 94;
 }
 console.log(x); // ! Ошибка
}
                </pre>
            </td>
         </tr>
         <tr>
            <td>
                <p>
                    Можно использовать в функции перед определением.
                </p>
                <pre>
function print(){
    console.log(x); // undefined, но норм
    var x = 76;
}
                </pre>
            </td>
            <td>
                <p>
                Можно использовать только после определения.
                </p>
                <pre>
function print(){
    console.log(x); // ! Ошибка
    let x = 76;
}
                </pre>
            </td>
         </tr>
         <tr>
            <td>
                <p>
                В одной и той же функции можно несколько раз определить переменную с одним и тем же именем.
                </p>
                <pre>
function print(){
    var x = 72;
    console.log(x); // 72
    var x = 24;     // норм
    console.log(x); // 24
}
                </pre>
            </td>
            <td>
                <p>
                В одной и той же функции можно только один раз определить переменную с одним и тем же именем.
                </p>
                <pre>
function print(){
    let x = 72;
    console.log(x); // 72
    let x = 24;     // ! Ошибка
    console.log(x);
}
                </pre>
            </td>
         </tr>
    </tbody>
    
</table>

###  Типы данных

TS является строго типизированным языком, и каждая переменная и константа в нем имеет определенный тип. При этом в отличии
от js мы не можем динамически изменить ранее указанный тип переменной.

В TS имеются следующие базовые типы:

* **Boolean**: логическое значение true или false
* **Number**: числовое значение
* **String**: строки
* **Array**: массивы
* **Tuple**: кортежи
* **Enum**: перечисления
* **Any**: произвольный тип
* **Null и undefined**: соответствуют значениям null и undefined в JS
* **Void**: отсутствие конкретного значения, используется в основном в качестве возвращаемого типа функций
* **Never**: также представляет отсутствие значения и используется в качестве возвращаемого типа функций, которые
генерируют или возвращают ошибку

Большинство из этих типов соотносятся с примитивными типа из JS.

Для установки типа применяется знак двоеточия. Примеры создания переменных:

```typescript
let x: number = 10;
let hello: string = "hello world";
let isValid: boolean = true;
```

То есть в данном случае выражение let hello: string = "hello world" указывает, что переменная hello будет иметь тип
string и значение hello world.

При этом если в коде мы потом захотим изменить тип, например:

```typescript
let hello: string = "hello world";
hello = 23;
```

То в процессе компиляции комплиятор TS выдаст ошибку, и мы попросту не сможем запустить программу.

Но можно в принципе и не указывать тип переменной. Например:

```typescript
let hello = "hello world";
hello = 23;
```

В этом случае TS автоматически выведет тип из присваемого данной переменной значения. Так, на первой строке компилятор
TS увидит, что переменной присваивается строка, поэтому для нее будет использоваться тип string. Однако на второй строке
опять же компилятор выдаст ошибку, поскольку у переменной уже опеределен тип string. А новое значение предполагает тип
number.

Если же переменная определяется без значения, и только впоследствии при работе программы ей присваивается значение, тогда считается,
что она имеет тип any:

```typescript
let x; // тип any
x = 10;
```

#### Boolean

Тип **Boolean** представляет логическое значение true или false:

```typescript
let isEnabled = true;
let isAlive: boolean = false;

console.log(isEnabled)
console.log(isAlive);
```

#### Number

Тип Number представляет числа, причем все числа в TS, как и в JS, являются числами с плавающей точкой. TS поддерживает 
двоичную, восьмеричную, десятичную и шестнадцатиричную записи чисел:

```typescript
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
```

#### String

String предствляет строки. Как и в JS, в TS строки можно заключать в двойные, либо в одинарные кавычки:

```typescript
let firstName: string = "Tom";
let lastName = 'Johns';
```

Кроме того, TS поддерживает такую функциональность, как шаблоны строк, то есть мы можем задать шаблон в косых кавычках
(`), как елси бы мы писали строку, и затем в саму строку можно встраивать разные выражения с помощью синтаксиса ${ expr },
где expr - это выражение. Например:

```typescript
let firstName: string = "Tom";
let age: number = 28;
let info: string = `Имя ${firstName}    Возраст: ${age}`;
console.log(info);  // Имя Tom    Возраст: 28
```

Косые кавычки также можно применять для установки многострочного текста:

```typescript
let sentence: string = `Hello World!
Goob bye World!`;
```

#### Null и undefined

Как и в JS, в TS есть специальные типы undefined и null, которые принимают соответствующие значения undefined и null:

```typescript
let a: undefined = undefined;
let b: null = null;
```

Но фактически мы можем присваивать значения undefined и null переменным других типов, например, number:

```typescript
let x: number = undefined;
console.log(x);
x = null;
console.log(x);
x = 5;
console.log(x);
```

В этом плане null и undefined выступают как подтипы других типов и полезны преимущественно в каких-то операциях, где
неизвестен результат - то ли это будет число или строка, то ли это будет null. В этом случае, чтобы избежать возможной
ошибки, мы можем проверить значение на undefined или null, собственно как и в js.

#### Массивы

Массивы определяются с помощью выражения [] и также являются строго типизированными. То есть если изначально массив
содержит строки, то в будущем он сможет работать только со строками.

```typescript
let list: number[] = [10, 20, 30];
let colors: string[] = ["red", "green", "blue"];
console.log(list[0]);
console.log(colors[1]);
```

Как и в JS, с помощью индексов можно обращаться к элементам массива.

Альтернативный способ определения массивов представляет применение типа Array<>;

```typescript
let names: Array<string> = ["Tom", "Bob", "Alice"];
console.log(names[1]);  // Bob
```

#### Кортежи

Кортежи (Tuples) также, как и массивы, представляют набор элементов, для которых уже заранее известен тип. Например:

```typescript
// определение кортежа - кортеж состоит из двух элементов - строки и числа
let userInfo: [string, number];
// инициализация кортежа
userInfo = ["Tom", 28];
// Неправильная инициализация - переданные значения не соответствуют типам по позиции
//userInfo = [28, "Tom"]; // Ошибка
 
// использование кортежа
console.log(userInfo[1]); // 28
userInfo[1] = 37;
```

#### Тип enum

Тип enum предназначен для описания набора числовых данных с помощью строковых констант. Так, объявим следующее перечисление:

```typescript
enum Season { Winter, Spring, Summer, Autumn };
```

Перечисление называется Season и имеет четыре элемента. Теперь используем перечисление:

```typescript
enum Season { Winter, Spring, Summer, Autumn };
let current: Season = Season.Summer;
console.log(current);
current = Season.Autumn; // изменение значения
```

Здесь создается переменная current, которая имеет тип Season. При этом консоль выведет нам число 2. Так как все элементы
перечисления представляют числовые значения. По умолчанию следующие:

```typescript
enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };
```

Хотя мы можем переопределить эти значения:

```typescript
enum Season { Winter=5, Spring, Summer, Autumn }; // 5, 6, 7, 8
enum Season { Winter=4, Spring=8, Summer=16, Autumn=32 }; // 4, 8, 16, 32
```

Также мы можем получить непосредственно текстовое значение:

```typescript
enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };
var current: string = Season[2]; // 2 - числовое значение Summer
console.log(current);  // Summer
```

#### Тип any

Any описывает данные, тип которых может быть неизвестен на момент написания приложения.

```typescript
let someVar: any = "Hello";
console.log(someVar); // сейчас someVar - это string
someVar = 20;
console.log(someVar); // сейчас someVar - это number
``` 
Так как здесь применяется тип any, то данный код скомпилируется без ошибок, несмотря на смену строкового значения на числовое.
И также мы можем объявлять массивы данного типа:

```typescript
var someArray: any[] = [ 24, "Tom", false ];
```

#### Комплексные объекты

Кроме простых переменных, как и в JS, можно создавать сложные объекты. Например:

```typescript
let person = { name: "Tom", age: 23 };
console.log(person.name);
// альтернативный вариант получения свойства
console.log(person["name"]);
```

Но несмотря на то, что это фактически тот же самый объект, что мы могли бы использовать в JS, в силу строготипизированности
TS мы имеем в данном случае ограничения. В частности, если у нас будет следующий код:

```typescript
let person = { name: "Tom", age: 23 };
person = { name: "Alice" };
```

То на второй строке мы получим ошибку, поскольку компилятор после первой строки предполагает, что объект person будет
иметь два свойства name и age. Должно быть соответствие по названиям, количеству и типу свойств. 

### Работа с типами данных

#### Объединения

Объединения или union не являются типом данных, но они позволяют определить переменную, которая может хранить значение двух
или более типов:

```typescript
let id: number | string;
id = "12345dgg5";
console.log(id); // 1345dgg5
id = 234;
console.log(id); // 234
```

Чтобы определить все типы, которые должно представлять перечисление, все эти типы разделяются прямой чертой: number | string.
В данном случае переменная id может представлять как тип string, то есть строку, так и число.

#### Проверка типа

С помощью оператора typeof мы можем проверить тип переменной. Это может быть необходимо, когда мы хотим выполнить некоторый
операции с переменной, но нам неизвестен ее точный тип (например, переменная представляет тип any). Данная функциональность
еще называется type guards или защита типа:

```typescript
let sum: any;
sum = 1200;
sum = "тысяча двести";
let result: number = sum / 12;
console.log(result); // Nan - строку нельзя разделить на число
```

Переменная sum может хранить любое значение, однако деление может работать только с числами. ПОэтому перед делением
выполним проверку на тип:

```typescript
let sum: any;
sum = 1200;

if (typeof sum === "number") {
    
    let result: number = sum / 12;
    console.log(result);
} else {
    console.log("invalid operation");
}
```

После оператора typeof указывается имя переменной, затем равно и название типа, на который идет проверка. Если переменная
соответствует типу, то оператор typeof возвращает значение true.

#### Псевдонимы типов

TypeScript позволяет определять псевдонимы типов с помощью ключевого слова type:

```typescript
type stringOrNumberType = number | string;
let sum: stringOrNumberType = 36.6;
if (typeof sum === "number") {
    console.log(sum / 6)
}
```

Далее мы сможем применять псеводним аналогично типу данных.

#### Type assertion

Type assertion представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях
одна переменная может представлять какой-то широкий тип, например, any, который по факту допускает значения различных
типов. Однако при этом нам надо использовать переменную как значение строго определенного типа. И в этом случае мы можем
привести к этому типу.

Есть две формы приведения. Первая форма заключается в использовании угловых скобок:

```typescript
let someAnyValue: any = "hello world!";
let strLength: number = (<string>someAnyValue).length;
console.log(strLength); // 12

let someUnionValue: string | number = "hello work";
strLength = (<string>someUnionValue).length;
console.log(strLength); // 10
```

Вторая форма заключается в применении оператора as:

```typescript
let someAnyValue: any = "hello world!";
let strLength: number = (someAnyValue as string).length;
console.log(strLength); // 12

let someUnionValue: string | number = "hello work";
strLength = (someUnionValue as string).length;
console.log(strLength); // 10
```



